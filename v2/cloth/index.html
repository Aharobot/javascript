<!doctype html>
<html lang="en">
	<head>
		<title>Leap Cloth</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				text-align: center;
				padding: 10px;
				z-index: 10;
				width: 100%;
				position: absolute;
			}

			a {
				text-decoration: underline;
				cursor: pointer;
			}
		</style>
	</head>

  <!--
  Other cloth demos:
  Tear the cloth with your mouse http://codepen.io/suffick/pen/KrAwx
  Cloth Physics in Three.js: http://www.kamend.com/2011/12/cloth-physics-in-three-js/
  Curtain Me: http://www.chromeexperiments.com/detail/curtain-me/?f=

  note -
  a constant wind could be a pretty interesting way to get shapes in VR (!)

  -->

	<body>
		<div id="info">Simple Cloth Simulation<br/>
			Verlet integration with Constrains relaxation<br/>
		</div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.js"></script>
    <script src="//js.leapmotion.com/leap-0.6.3.min.js"></script>
    <script src="js/leap-plugins-0.1.9pre.js"></script>
    <script src="js/leap.pinchEvent.js"></script>
		<script src="js/Stats.js"></script>

		<script src="js/Cloth.js"></script>

		<script type="x-shader/x-fragment" id="fragmentShaderDepth">

			uniform sampler2D texture;
			varying vec2 vUV;

			vec4 pack_depth( const in float depth ) {

				const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
				const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;

			}

			void main() {

				vec4 pixel = texture2D( texture, vUV );

				if ( pixel.a < 0.5 ) discard;

				gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );

			}
		</script>

		<script type="x-shader/x-vertex" id="vertexShaderDepth">

			varying vec2 vUV;

			void main() {

				vUV = 0.75 * uv;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script>

      var stats = new Stats();
      stats.setMode(1); // 0: fps, 1: ms


      // Align top-left
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';
      document.body.appendChild( stats.domElement );


			var camera, scene, renderer;

			var
          cloth;
			var mesh, arrow;

      Leap.loop({background: true})
        .use('transform', {
          quaternion: (new THREE.Quaternion),
          position: new THREE.Vector3(0,-200,0),
          scale: 0.75
        })
        .use('boneHand', {
          scene: null
        })
        .use('pinchEvent');

      Leap.loopController.setBackground(true); // see https://github.com/leapmotion/leapjs/issues/190

      Leap.loopController.on('hand', function(hand){
        if (hand.data('pinchEvent.pinching') || true){
          for (var i = 0; i < colliders.length; i++){
            colliders[i].position.fromArray( hand.fingers[i % 5].tipPosition );
          }
        }
      });

			init();
			animate();

			function init() {

				// scene

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xcce0ff, 500, 10000 );

        Leap.loopController.plugins.boneHand.scene = scene;

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.x = 100;
				camera.position.y = 150;
				camera.position.z = 1500;
				scene.add( camera );

        for (var i = 0; i < colliders.length; i++){
          scene.add(colliders[i]);
        }

				// lights


				scene.add( new THREE.AmbientLight( 0x666666 ) );

				var light;
				light = new THREE.DirectionalLight( 0xcccccc, 1.75 );
				light.position.set( 50, 200, 100 );
				light.position.multiplyScalar( 1.3 );

				light.castShadow = true;
				//light.shadowCameraVisible = true;

				light.shadowMapWidth = 1024;
				light.shadowMapHeight = 1024;

				var d = 300;

				light.shadowCameraLeft = -d;
				light.shadowCameraRight = d;
				light.shadowCameraTop = d;
				light.shadowCameraBottom = -d;

				light.shadowCameraFar = 1000;
				light.shadowDarkness = 0.5;

				scene.add( light );


//        cloth = new Cloth(100, 100, 2.5);
        cloth = new Cloth(50, 50, 5);
//        cloth = new Cloth(10, 10);

        // Four corners:
        cloth.pinAt(0,0);
        cloth.pinAt(0,10);
        cloth.pinAt(10,0);
        cloth.pinAt(10,10);

				// cloth material

				var clothTexture = THREE.ImageUtils.loadTexture( 'LARGE-3-420 oiling 9000.Tif.jpg' );
				clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
				clothTexture.anisotropy = 16;

				var clothMaterial = new THREE.MeshPhongMaterial( {
          alphaTest: 0.5,
          ambient: 0xffffff,
          color: 0xffffff,
          specular: 0x030303,
          emissive: 0x111111,
          shiness: 10,
          map: clothTexture,
          side: THREE.DoubleSide//,
//          wireframe: true
        } );

				var uniforms = { texture:  { type: "t", value: clothTexture } };
				var vertexShader = document.getElementById( 'vertexShaderDepth' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShaderDepth' ).textContent;

				// cloth mesh

				mesh = new THREE.Mesh( cloth.geometry, clothMaterial );
				mesh.position.set( 0, 0, 0 );
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				scene.add( mesh );

        cloth.mesh = mesh; // bad

				mesh.customDepthMaterial = new THREE.ShaderMaterial( {
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader
        } );



				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( scene.fog.color );

        document.body.appendChild( renderer.domElement );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				renderer.shadowMapEnabled = true;

				//


				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}


			function animate() {
				requestAnimationFrame( animate );

        stats.begin();

				cloth.simulate( Date.now() );
				render();

        stats.end();

			}

			function render() {

				camera.lookAt( scene.position.clone().setX(125) );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
