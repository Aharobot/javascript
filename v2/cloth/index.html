<!doctype html>
<html lang="en">
	<head>
		<title>Leap Cloth</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				text-align: center;
				padding: 10px;
				z-index: 10;
				width: 100%;
				position: absolute;
			}

			a {
				text-decoration: underline;
				cursor: pointer;
			}
		</style>
	</head>

  <!--
  Other cloth demos:
  Tear the cloth with your mouse http://codepen.io/suffick/pen/KrAwx
  Cloth Physics in Three.js: http://www.kamend.com/2011/12/cloth-physics-in-three-js/
  Curtain Me: http://www.chromeexperiments.com/detail/curtain-me/?f=

  note -
  a constant wind could be a pretty interesting way to get shapes in VR (!)

  -->

	<body>
		<div id="info">Simple Cloth Simulation<br/>
			Verlet integration with Constrains relaxation<br/>
			Toggle: <a onclick="rotate = !rotate;">Camera</a> |
			<a onclick="sphere.visible = !sphere.visible;">Ball</a>
		</div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
    <script src="//js.leapmotion.com/leap-0.6.3.min.js"></script>
    <script src="js/leap-plugins-0.1.9pre.js"></script>
    <script src="js/leap.pinchEvent.js"></script>

		<script src="js/Cloth.js"></script>

		<script type="x-shader/x-fragment" id="fragmentShaderDepth">

			uniform sampler2D texture;
			varying vec2 vUV;

			vec4 pack_depth( const in float depth ) {

				const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
				const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;

			}

			void main() {

				vec4 pixel = texture2D( texture, vUV );

				if ( pixel.a < 0.5 ) discard;

				gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );

			}
		</script>

		<script type="x-shader/x-vertex" id="vertexShaderDepth">

			varying vec2 vUV;

			void main() {

				vUV = 0.75 * uv;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script>

			/* testing cloth simulation */

      var cloth = new Cloth(10, 10);


      // Four corners:

      cloth.pinAt(0,0);
      cloth.pinAt(0,10);
      cloth.pinAt(10,0);
      cloth.pinAt(10,10);

			var container;
			var camera, scene, renderer;

			var clothGeometry;
			var sphere;
			var object, arrow;

			var rotate = false;

      Leap.loop({background: true})
        .use('transform', {
          quaternion: (new THREE.Quaternion),
          position: new THREE.Vector3(0,-200,-100),
          scale: 0.75
        })
        .use('boneHand', {
          scene: null
        })
        .use('pinchEvent');

      Leap.loopController.on('hand', function(hand){
        if (hand.data('pinchEvent.pinching') || true){
          ballPosition.fromArray( hand.indexFinger.tipPosition );
        }
      });

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// scene

				scene = new THREE.Scene();

				scene.fog = new THREE.Fog( 0xcce0ff, 500, 10000 );

        Leap.loopController.plugins.boneHand.scene = scene;

				// camera

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 50;
				camera.position.z = 2200;
				scene.add( camera );

				// lights

				var light;

				scene.add( new THREE.AmbientLight( 0x666666 ) );

				light = new THREE.DirectionalLight( 0xdfebff, 1.75 );
				light.position.set( 50, 200, 100 );
				light.position.multiplyScalar( 1.3 );

				light.castShadow = true;
				//light.shadowCameraVisible = true;

				light.shadowMapWidth = 1024;
				light.shadowMapHeight = 1024;

				var d = 300;

				light.shadowCameraLeft = -d;
				light.shadowCameraRight = d;
				light.shadowCameraTop = d;
				light.shadowCameraBottom = -d;

				light.shadowCameraFar = 1000;
				light.shadowDarkness = 0.5;

				scene.add( light );

        var ballGeo = new THREE.SphereGeometry( 20, 20, 20 );



        for (var i = 0; i < cloth.pinnedParticles.length; i++){
          var ballMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff * ( i / cloth.pinnedParticles.length ) } );
          sphere = new THREE.Mesh( ballGeo, ballMaterial );
          sphere.position.copy(cloth.pinnedParticles[i].position);

          console.log(sphere.position);
          scene.add(sphere);
        }

				// cloth material

				var clothTexture = THREE.ImageUtils.loadTexture( 'circuit_pattern.png' );
				clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
				clothTexture.anisotropy = 16;

				var clothMaterial = new THREE.MeshPhongMaterial( {
          alphaTest: 0.5,
          ambient: 0xffffff,
          color: 0xffffff,
          specular: 0x030303,
          emissive: 0x111111,
          shiness: 10,
          map: clothTexture,
          side: THREE.DoubleSide,
          wireframe: true
        } );

				// cloth geometry
				clothGeometry = new THREE.ParametricGeometry( cloth.particlePosition, cloth.w, cloth.h );


        // just in case for now ?
//        var diff = clothGeometry.mergeVertices();
//        console.log('removed ', diff, ' vertices by merging');

				clothGeometry.dynamic = true;
				clothGeometry.computeFaceNormals();

				var uniforms = { texture:  { type: "t", value: clothTexture } };
				var vertexShader = document.getElementById( 'vertexShaderDepth' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShaderDepth' ).textContent;

				// cloth mesh

				object = new THREE.Mesh( clothGeometry, clothMaterial );
				object.position.set( 0, 0, 0 );
				object.castShadow = true;
				object.receiveShadow = true;
				scene.add( object );

				object.customDepthMaterial = new THREE.ShaderMaterial( {
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader
        } );




				// sphere

				var ballGeo = new THREE.SphereGeometry( ballSize, 20, 20 );
				var ballMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

				sphere = new THREE.Mesh( ballGeo, ballMaterial );
				sphere.castShadow = true;
				sphere.receiveShadow = true;
				scene.add( sphere );

				// arrow

				arrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 0 ), 50, 0xff0000 );
				arrow.position.set( -200, 0, -200 );
			  scene.add( arrow );


				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( scene.fog.color );

				container.appendChild( renderer.domElement );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				renderer.shadowMapEnabled = true;

				//


				window.addEventListener( 'resize', onWindowResize, false );

				sphere.visible = true

			}

			//

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				var time = Date.now();

				cloth.simulate(time);
				render();

			}

			function render() {

				var timer = Date.now() * 0.0002;

				var particles = cloth.particles;

				for ( var i = 0, il = particles.length; i < il; i ++ ) {

					clothGeometry.vertices[ i ].copy( particles[ i ].position );

				}

				clothGeometry.computeFaceNormals();
				clothGeometry.computeVertexNormals();

				clothGeometry.normalsNeedUpdate = true;
				clothGeometry.verticesNeedUpdate = true;

				sphere.position.copy( ballPosition );

				if ( rotate ) {

					camera.position.x = Math.cos( timer ) * 1500;
					camera.position.z = Math.sin( timer ) * 1500;

				}

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
